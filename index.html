
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Lancy's Blog</title>
	<meta name="author" content="Lancy">

	
	<meta name="description" content="Variable argument lists 使用方法 可变参数函数（Variadic Function），即是指一个可以接受可变数量的参数的函数。在C语言中，对该特性的支持，即是通过可变参数列表（Variable Argument list）来实现的，其定义在stdarg.h头文件。( &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Lancy's Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">Lancy's Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="https://github.com/lancy/cyhelper">CYHelper</a></li>
	<li><a href="/about">About Me</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
	<li><a href="https://github.com/lancy/cyhelper">CYHelper</a></li>
	<li><a href="/about">About Me</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:gracelancy.com">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		<a class="weibo" href="http://weibo.com/lancy1014"
            title="Weibo">Weibo</a>
		
		
		<a class="github" href="https://github.com/lancy" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:gracelancy.com">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/05/05/variable-argument-lists/">
		
			Variable Argument Lists</a>
	</h2>
	<div class="entry-content">
		<h2>Variable argument lists 使用方法</h2>

<p>可变参数函数（Variadic Function），即是指一个可以接受可变数量的参数的函数。在C语言中，对该特性的支持，即是通过可变参数列表（Variable Argument list）来实现的，其定义在<code>stdarg.h</code>头文件。(若使用C++则在<code>cstdarg</code>头文件)。</p>

<p>以如下C代码为例说明，该函数接受可变数量的整数作为参数，求和：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">addemUp</span> <span class="p">(</span><span class="kt">int</span> <span class="n">firstNum</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 1. 参数后面添加省略号...</span>
</span><span class='line'>    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>  <span class="c1">// 2. 创建一个va_list类型的变量</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">firstNum</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">firstNum</span><span class="p">);</span> <span class="c1">// 3. 初始化va_list，此时va_list指向firstNum之后的第一个参数</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">number</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 4. 获取当前指向的参数的值，并移动到下一个参数</span>
</span><span class='line'>        <span class="n">sum</span> <span class="o">+=</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">// 用0表示结束</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span> <span class="c1">// 5. 清理</span>
</span><span class='line'>    <span class="k">return</span>  <span class="n">sum</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 调用</span>
</span><span class='line'><span class="n">sum</span> <span class="o">=</span> <span class="n">addemUp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="c1">// sum = 15</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>要创建一个可变参数函数，需要把一个省略号（&hellip;)放在函数的参数列表后面。</li>
<li>接着需要声明一个一个<code>va_list</code>类型的变量，这个<code>va_list</code>类型的变量类似于一个指向参数的指针。</li>
<li>接着我们调用<code>va_start()</code>并传入函数的最后一个声明的参数的变量名，来使得<code>va_list</code>变量指向第一个附加的参数。</li>
<li>接着我们调用<code>va_arg()</code>并传入我们期待的参数类型，程序就会返回与该类型匹配数量的字节（即参数的值），并且移动<code>va_list</code>指向下一个参数。之后不断的调用<code>va_arg()</code>，获得更多的参数的值，直到完成整个参数处理的过程。</li>
<li>最后调用<code>va_end()</code>来进行清理。</li>
</ol>


<h2>variable argument lists 的内部机制</h2>

<p>如我们之前所说，当我们调用<code>va_start()</code>并将<code>va_list</code>和函数最后定义的参数传入时，实际上是将<code>va_list</code>内在的一个指针指向函数调用栈 （<a href="http://en.wikipedia.org/wiki/Call_stack#Functions_of_the_call_stack">call stack</a>）中参数所在的区域的一端，每一次我们调用<code>va_arg()</code>，其都会根据提供的类型，返回当前指针所指向的地址开始对应的字节数的数据，即参数的值，并移动指针相应字节数的距离。我们传给<code>va_arg()</code>的类型，即是其用来判定需要取得得数据的大小，以及指针需要移动的距离。如图描述了这个过程：</p>

<p><img src="/assets/post/val0.png" alt="call stack" style="width: 600px;"/></p>

<p>事实上，这是一个很危险的事情，你总是需要提供正确的类型来让<code>va_arg()</code>正确执行，而且<code>va_arg()</code>并不知道何时停止，你需要提供一个标记或一个参数的总数来停止<code>va_arg()</code>继续执行。若你提供了不正确的类型，或者没有在该停止的时候停止，你将会获得不可预测的值，并且很有可能导致程序崩溃。</p>

<h2>解决方案</h2>

<p>一般而言，为了确保参数的获取正确进行，有如下两种解决方案：</p>

<h3>Format string</h3>

<p>如C语言中的<code>printf</code>，Cocoa中的<code>NSLog</code>，<code>[NSString stringWithFormat:]</code>就是使用了Format String的解决方案。通常，该函数的第一个参数既为一个format string，函数内部实现会扫描这个format string，来确定之后接着的可变参数的数量和类型。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;int %d, str %@, float %g&quot;</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="s">@&quot;ok&quot;</span><span class="p">,</span> <span class="mf">123.4</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里使用了%作为转义符，其后跟着的d代表int，@代表id，g代表float/double，这表示后面必须有三个参数，其类型必须与format string所指定的一致。</p>

<p>如之前所说，提供的参数的数量或者类型若与提供的format string不一致，则会发生不可预知的问题。而在运行的时候，我们没有任何的办法去保证其正确性，幸运的是编译器提供了一些方法，能让我们在编译的时候做一些检查：</p>

<p>gcc中定义了<code>__attribute__((format))</code>来标示一个可变参函数使用了format string，从而在编译时对其进行检查。其定义为<code>format (archetype, string-index, first-to-check)</code>，其中<code>archetype</code>代表format string的类型，它可以是<code>printf</code>，<code>scanf</code>，<code>strftime</code>或者<code>strfmon</code>，Cocoa开发者还可以使用<code>__NSString__</code>来指定其使用和<code>[NSString stringWithFormat:]</code>与<code>NSLog()</code>一致的format string规则。<code>string-index</code>代表format string是第几个参数，<code>first-to-check</code>则代表了可变参数列表从第几个参数开始。示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 第一个参数是format，第二个参数起是可变参数列表，format的格式规则与printf一致</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">customPrintf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">format</span><span class="p">(</span><span class="n">printf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 使用的时候，若format和参数不符，则会报warning</span>
</span><span class='line'><span class="n">customPrintf</span><span class="p">(</span><span class="s">&quot;what? %d&quot;</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cocoa开发者可以使用<code>NS_FORMAT_FUNCTION(F,A)</code>宏来替代<code>__atribute__format</code>，F和A即对应<code>string-index</code>和<code>first-to-check</code>，事实上，他的实现类似于：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>示例如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">FOUNDATION_EXPORT</span> <span class="kt">void</span> <span class="nf">NSLog</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span> <span class="n">NS_FORMAT_FUNCTION</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Sentinel value</h3>

<p>哨兵值是另一种可变参数列表所常用的方案，如前一节我们的示例代码，即是使用了数字0作为哨兵值。当程序发现当前读取到的参数值为0时，则停止继续读取程序。在Cocoa中，我们经常使用<code>nil</code>作为哨兵值，比如<code>[NSArray arrayWithObjects:]</code>方法，其接受数量不等的对象作为参数，而在最后则必须使用nil结尾。如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">NSArray</span> <span class="nl">arrayWithObjects:</span><span class="err">@</span><span class="mi">1</span><span class="p">,</span> <span class="err">@</span><span class="mi">2</span><span class="p">,</span> <span class="err">@</span><span class="mi">3</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="c1">//备注：我们现在通常使用@[@1, @2, @3]来代替这一行代码，且不需要在最后添加nil，这称为字面量（Literals)</span>
</span></code></pre></td></tr></table></div></figure>


<p>同format string一样危险的是，若开发者调用方法（函数）的时候，忘记在最后添加上哨兵值，则会发生不可预知的问题。同样幸运的是，编译器也为我们提供了一些方法来在编译时进行检查。</p>

<p>gcc中定义了<code>___attribute__((sentinel))</code>来标示一个函数需要在编译的时候对哨兵值进行检查。用法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">addemUp</span> <span class="p">(</span><span class="kt">int</span> <span class="n">firstNum</span><span class="p">,</span> <span class="p">...)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">sentinel</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cocoa开发者可以使用<code>NS_REQUIRES_NIL_TERMINATION</code>宏来替代，其实现基本等同于上述代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">arrayWithObjects:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">firstObj</span><span class="p">,</span> <span class="p">...</span> <span class="n">NS_REQUIRES_NIL_TERMINATION</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>工程实例</h2>

<p>我在开发猿题库iOS客户端时，由于产品的需要会有许多alert弹框。但传统的<code>UIAlertView</code>经常需要实现相应的<code>UIAlertViewDelegate</code>，使用起来非常不便。我写了一个能够接收block作为回调的自定义的AlertView组件，同时为了保证其接口与<code>UIAlertView</code>基本一致，使用了可变参数列表。其接口定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">CYAlertView</span> : <span class="nc">UIAlertView</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithTitle:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">title</span>
</span><span class='line'>            <span class="nf">message:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">message</span>
</span><span class='line'>         <span class="nf">clickedBlock:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">CYAlertView</span> <span class="o">*</span><span class="n">alertView</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="n">cancelled</span><span class="p">,</span> <span class="n">NSInteger</span> <span class="n">buttonIndex</span><span class="p">))</span><span class="nv">clickedBlock</span>
</span><span class='line'>  <span class="nf">cancelButtonTitle:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">cancelButtonTitle</span>
</span><span class='line'>  <span class="nf">otherButtonTitles:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">otherButtonTitles</span><span class="p">,</span> <span class="p">...</span> <span class="n">NS_REQUIRES_NIL_TERMINATION</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>完整的代码开源托管在GitHub（<a href="https://github.com/lancy/cyalertview">传送门</a>），有兴趣的同学可以参考。</p>

<h2>联系我</h2>

<p>水平有限，若有任何关于该文章的疑问或者指正，欢迎和我讨论</p>

<ul>
<li>写邮件：lancy1014#gmail.com</li>
<li>关注我的<a href="http://weibo.com/lancy1014/">微博</a></li>
<li>Fo我的<a href="http://github.com/lancy">Github</a></li>
<li>在这里写评论留言</li>
</ul>


<h2>参考</h2>

<ul>
<li><a href="http://clang.llvm.org/docs/AttributeReference.html#format-gnu-format">Clang 3.5 documentation: Attributes in Clang</a></li>
<li><a href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">GCC documentation: Function Attributes</a></li>
<li><a href="http://nshipster.com/__attribute__/">NSHisper: <strong>attribute</strong> </a></li>
<li>Advanced Mac OS X Programming</li>
</ul>


<p>lancy</p>

<p>2014.5.12</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-05-05T00:11:00+08:00" pubdate data-updated="true">May 5<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/blog/2014/05/05/variable-argument-lists/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/04/21/toll-free-bridging/">
		
			Toll-Free Bridging</a>
	</h2>
	<div class="entry-content">
		<h2>什么是 Toll-Free Bridging</h2>

<p>有一些数据类型是能够在 Core Foundation Framework 和 Foundation Framework 之间交换使用的。这意味着，对于同一个数据类型，你既可以将其作为参数传入 Core Foundation 函数，也可以将其作为接收者对其发送 Objective-C 消息（即调用ObjC类方法）。这种在 Core Foundation 和 Foundation 之间交换使用数据类型的技术就叫 Toll-Free Bridging.</p>

<p>举例说明，<code>NSString</code>和<code>CFStringRef</code>即是一对可以相互转换的数据类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// ARC 环境下</span>
</span><span class='line'><span class="c1">// Bridging from ObjC to CF</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">hello</span> <span class="o">=</span> <span class="s">@&quot;world&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">world</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">CFStringRef</span><span class="p">)(</span><span class="n">hello</span><span class="p">);</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span> <span class="n">CFStringGetLength</span><span class="p">(</span><span class="n">world</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Bridging from CF to ObjC</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">hello</span> <span class="o">=</span> <span class="n">CFStringCreateWithCString</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">kCFStringEncodingUTF8</span><span class="p">);</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">world</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">NSString</span> <span class="o">*</span><span class="p">)(</span><span class="n">hello</span><span class="p">);</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span> <span class="n">world</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
</span><span class='line'><span class="n">CFRelease</span><span class="p">(</span><span class="n">hello</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>大部分（但不是所有！）Core Foundation 和 Foundation 的数据类型可以使用这个技术相互转换，Apple 的文档里有一个列表（<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">传送门</a>），列出了支持这项技术的数据类型。</p>

<p>MRC 下的 Toll-Free Bridging 因为不涉及内存管理的转移，可以直接相互 bridge 而不必使用类似<code>__bridge</code>修饰字，我们之后再讨论这个问题。</p>

<h2>Toll-Free Bridging 是如何实现的？</h2>

<h4>1.</h4>

<p>每一个能够 bridge 的 ObjC 类，都是一个<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html#//apple_ref/doc/uid/TP40010810-CH4-SW1">类簇（class cluster）</a>。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该 ObjC 类相对应的 Core Foundation 类的内存结构，正好与类簇的其中一个私有子类相同。</p>

<p>举个例子，<code>NSString</code>是一个类簇，一个公开的抽象类，但每次创建一个<code>NSString</code>的实例时，实际上我们会获得其中一个私有子类的实例。而<code>NSString</code>的其中一个私有子类实现既为<code>NSCFString</code>，其内存的结构与<code>CFString</code>是相同的，<code>CFString</code>的<code>isa</code>指针就指向<code>NSCFString</code>类，即，<code>CFString</code>对象就是一个<code>NSCFString</code>类的实例。</p>

<p>所以，当<code>NSString</code>的实现刚好是<code>NSCFString</code>的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。</p>

<h4>2.</h4>

<p>当<code>NSString</code>的实现不是<code>NSCFString</code>的时候（比如我们自己 subclass 了<code>NSString</code>），我们调用 CF 函数，就需要先检查对象的具体实现。如果发现其不是<code>NSCFString</code>，我们不会调用 CF 函数的实现来获得结果，而是通过给对象发送与函数功能相对应的 ObjC 消息（调用相对应的<code>NSString</code>的接口）来获得其结果。</p>

<p>例如<code>CFStringGetLength</code>函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是<code>NSCFString</code>实现。如果是的话，就会直接调用<code>CFStringGetLength</code>函数的实现来获得字符串的长度；如果不是的话，会给对象发送<code>length</code>消息（调用<code>NSString</code>的<code>- (NSUInteger)length</code>接口），来得到字符串的长度。</p>

<p>通过这样的技术，即使是我们自己子类了一个<code>NSString</code>，也可以和<code>CFStringRef</code>相互 Bridge。</p>

<h4>3.</h4>

<p>其他支持 Toll-Free Bridging 的数据类型原理也同<code>NSString</code>一样，比如<code>NSNumber</code>的<code>NSCFNumber</code>和<code>CFNumber</code>。</p>

<h2>ARC 下的 Toll-Free Bridging</h2>

<p>如之前提到的，MRC 下的 Toll－Free Bridging 因为不涉及内存管理的转移，相互之间可以直接交换使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// bridge</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">nsStr</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">cfStr</span><span class="p">;</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">cfStr</span> <span class="o">=</span> <span class="p">(</span><span class="n">CFStringRef</span><span class="p">)</span><span class="n">nsStr</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 调用函数或者方法</span>
</span><span class='line'><span class="n">NSUInteger</span> <span class="n">length</span> <span class="o">=</span> <span class="p">[(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">cfStr</span> <span class="n">length</span><span class="p">];</span>
</span><span class='line'><span class="n">NSUInteger</span> <span class="n">length</span> <span class="o">=</span> <span class="n">CFStringGetLength</span><span class="p">((</span><span class="n">CFStringRef</span><span class="p">)</span><span class="n">nsStr</span><span class="p">);</span>
</span><span class='line'><span class="c1">// release</span>
</span><span class='line'><span class="n">CFRelease</span><span class="p">((</span><span class="n">CFStringRef</span><span class="p">)</span><span class="n">nsStr</span><span class="p">);</span>
</span><span class='line'><span class="p">[(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">cfStr</span> <span class="n">release</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>而在 ARC 下，事情就会变得复杂一些，因为 ARC 能够管理 Objective-C 对象的内存，却不能管理 CF 对象，CF 对象依然需要我们手动管理内存。在 CF 和 ObjC 之间 bridge 对象的时候，问题就出现了，编译器不知道该如何处理这个同时有 ObjC 指针和 CFTypeRef 指向的对象。</p>

<p>这时候，我们需要使用<code>__bridge</code>, <code>__bridge_retained</code>, <code>__bridge_transfer</code> 修饰符来告诉编译器该如何去做。</p>

<h3>__bridge</h3>

<p>最常用的修饰符，这意味着告诉编译器不做任何内存管理的事情，编译器仍然负责管理好在 Objc 一端的引用计数的事情，开发者也继续负责管理好在 CF 一端的事情。举例说明：</p>

<h4>例子1</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// objc to cf</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">nsStr</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">createSomeNSString</span><span class="p">];</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">cfStr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">nsStr</span><span class="p">;</span>
</span><span class='line'><span class="n">CFUseCFString</span><span class="p">(</span><span class="n">cfStr</span><span class="p">);</span>
</span><span class='line'><span class="c1">// CFRelease(cfStr); 不需要</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，编译器会继续负责<code>nsStr</code>的内存管理的事情，不会在 bridge 的时候 retain 对象，所以也不需要开发者在 CF 一端释放。需要注意的是，当<code>nsStr</code>被释放的时候（比如出了作用域），意味着<code>cfStr</code>指向的对象被释放了，这时如果继续使用<code>cfStr</code>将会引起程序崩溃。</p>

<h4>例子2</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// cf to objc</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">hello</span> <span class="o">=</span> <span class="n">CFStringCreateWithCString</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">kCFStringEncodingUTF8</span><span class="p">);</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">world</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">NSString</span> <span class="o">*</span><span class="p">)(</span><span class="n">hello</span><span class="p">);</span>
</span><span class='line'><span class="n">CFRelease</span><span class="p">(</span><span class="n">hello</span><span class="p">);</span> <span class="c1">// 需要</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">useNSString:</span><span class="n">world</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，bridge 的时候编译器不会做任何内存管理的事情，bridge 之后，会负责 ObjC 一端的内存管理的事情 。同时，开发者需要负责管理 CF 一端的内存管理的事情，需要再 bridge 之后，负责 release 对象。</p>

<h3>__bridge_retained</h3>

<p>接<code>__bridge</code>一节的第一个例子，objc to cf。为了防止<code>nsStr</code>被释放，引起我们使用<code>cfStr</code>的时候程序崩溃，可以使用<code>__bridge_retained</code>修饰符。这意味着，在 bridge 的时候，编译器会 retain 对象，而由开发者在 CF 一端负责 release。这样，就算<code>nsStr</code>在 objc 一端被释放，只要开发者不手动去释放<code>cfStr</code>，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// objc to cf</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">nsStr</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">createSomeNSString</span><span class="p">];</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">cfStr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_retained</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">nsStr</span><span class="p">;</span>
</span><span class='line'><span class="n">CFUseCFString</span><span class="p">(</span><span class="n">cfStr</span><span class="p">);</span>
</span><span class='line'><span class="n">CFRelease</span><span class="p">(</span><span class="n">cfStr</span><span class="p">);</span> <span class="c1">// 需要</span>
</span></code></pre></td></tr></table></div></figure>


<h3>__bridge_transfer</h3>

<p>接<code>__bridge</code>一节的第二个例子，cf to objc。我们发现如果使用<code>__bridge</code>修饰符在cf转objc的时候非常的麻烦，我们既需要一个<code>CFTypeRef</code>的变量，还需要在 bridge 之后负责释放。这时我们可以使用<code>__bridge_transfer</code>，意味着在 bridge 的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// cf to objc</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">hello</span> <span class="o">=</span> <span class="n">CFStringCreateWithCString</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">kCFStringEncodingUTF8</span><span class="p">);</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">world</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_transfer</span> <span class="n">NSString</span> <span class="o">*</span><span class="p">)(</span><span class="n">hello</span><span class="p">);</span>
</span><span class='line'><span class="c1">// CFRelease(hello); 不需要</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">useNSString:</span><span class="n">world</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>甚至可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// cf to objc</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">world</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_transfer</span> <span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFStringCreateWithCString</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">kCFStringEncodingUTF8</span><span class="p">);</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">useNSString:</span><span class="n">world</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>小结</h3>

<ul>
<li><code>(__bridge T) op</code>：告诉编译器在 bridge 的时候不要做任何事情</li>
<li><code>(__bridge_retained T) op</code>：（ ObjC 转 CF 的时候使用）告诉编译器在 bridge 的时候 retain 对象，开发者需要在CF一端负责释放对象</li>
<li><code>(__bridge_transfer T) op</code>：（ CF 转 ObjC 的时候使用）告诉编译器转移 CF 对象的所有权，开发者不再需要在CF一端负责释放对象</li>
</ul>


<h2>联系我</h2>

<p>水平有限，若有任何关于该文章的疑问或者指正，欢迎和我讨论</p>

<ul>
<li>写邮件：lancy1014#gmail.com</li>
<li>关注我的<a href="http://weibo.com/lancy1014/">微博</a></li>
<li>Fo我的<a href="http://github.com/lancy">Github</a></li>
<li>在这里写评论留言</li>
</ul>


<h2>参考</h2>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">Concepts in Objective-C Programming</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/corefoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677">Core Foundation Design Concepts</a></li>
<li><a href="https://mikeash.com/pyblog/friday-qa-2010-01-22-toll-free-bridging-internals.html">Toll Free Bridging Internals</a></li>
<li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#bridged-casts">Clang documentation: Objective-C Automatic Reference Counting (ARC)</a></li>
</ul>


<p>Lancy</p>

<p>4.21</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-04-21T13:44:00+08:00" pubdate data-updated="true">Apr 21<span>st</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/blog/2014/04/21/toll-free-bridging/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/10/19/WordHacker/">
		
			如何做一个Letterpress拼词器</a>
	</h2>
	<div class="entry-content">
		<p><img src="/assets/post/wordhacker0.png" alt="Drawing" style="width: 200px;"/></p>

<h2>故事</h2>

<p>哥哥家的猫咪有一天迷上了风靡全球的拼词游戏Letterpress，但是贪吃的小猫咪只认识“food”和“milk”这样的词语，所以经常被对面的玩家欺负。可怜的小猫咪向哥哥求助：“喵呜~哥哥~哥哥，他欺负我！”，于是充满爱心和正义感的哥哥就踏上了拯救猫咪的道路。</p>

<p><img src="/assets/post/wordhacker1.jpg" alt="image" /></p>

<h2>开始拯救世界</h2>

<p>唔，我们马上来做一个自动拼词器，拼词器必须实现这样的功能：</p>

<ol>
<li>猫咪只需要选择一张游戏截图，拼词器能自动识别游戏提供的字母。（记住：小喵掌是用不了键盘的哦</li>
<li>拼词器根据识别出来的字母，自动拼出所有可能的单词，并按长度由长到短排序显示。（小猫咪就能方便的挑选单词啦</li>
</ol>


<p>有了这样的工具，连猫咪都能玩拼词游戏啦！</p>

<p>全部的代码在Github开源托管：<a href="https://github.com/lancy/letterfun">点这里</a></p>

<h2>正式的开始</h2>

<p>我们会使用到Xcode5，并创建一个iOS7的应用。我将用到CoreGraph来做图像处理，你需要一些图像处理的基本常识，一些C语言的能力以及一点内存管理的知识。</p>

<p>现在开始吧！</p>

<p>首先创建一个新的Xcode工程，模板选择单页面即可，名字就叫LetterFun（或者任何你和你的猫咪喜欢的名字），设备选择iPhone，其他的选项让你家猫咪决定。</p>

<p>接下来创建一个继承自<code>NSObject</code>的类<code>CYLetterManager</code>，我们将用它来识别游戏截图里面的字母。在头文件加上这些方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// CYLetterManager.h</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">CYLetterManager</span> : <span class="nc">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithImage:</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nv">image</span><span class="p">;</span>           <span class="err">\\</span> <span class="mi">1</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">trainingWihtAlphabets:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="n">array</span><span class="p">;</span> <span class="err">\\</span> <span class="mi">2</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="n">ocrAlphabets</span><span class="p">;</span>                      <span class="err">\\</span> <span class="mi">3</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>我们假定一个<code>CYLetterManager</code>的实例只处理一个图片，所以我们使用一个<code>initWithImage:</code>的方法，来确保需要我们处理的图片总是被事先载入。</li>
<li><code>trainingWihtAlphabets:</code>是一个训练方法，我们人工载入识别后的字母来让其进行训练，以提供后续字母识别的样本。</li>
<li><code>ocrAlphabets</code>从图片里识别字母。</li>
</ol>


<p>接着开始实现<code>CYLetterManager</code>。首先申明一些需要使用的变量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// CYLetterManager.m</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">CYLetterManager</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGImageRef</span> <span class="o">*</span><span class="n">_tagImageRefs</span><span class="p">;</span>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">_image</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGImageRef</span> <span class="o">*</span><span class="n">_needProcessImage</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>_image</code>是我们从<code>initWithImage:</code>里初始化得到的图像，其他两个变量，我会在后面用到的时候解释。</p>

<p>实现初始化方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithImage:</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nv">image</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="n">getNeedProcessImages</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接着实现<code>getNeedProcessImages</code>，这个方法用来将原图片切分为25个字母的小块，并存入<code>_needProcessImage</code>数组内。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">getNeedProcessImages</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// 1</span>
</span><span class='line'>  <span class="n">CGImageRef</span> <span class="n">originImageRef</span> <span class="o">=</span> <span class="p">[</span><span class="n">_image</span> <span class="n">CGImage</span><span class="p">];</span>
</span><span class='line'>  <span class="n">CGImageRef</span> <span class="n">alphabetsRegionImageRef</span> <span class="o">=</span> <span class="n">CGImageCreateWithImageInRect</span><span class="p">(</span><span class="n">originImageRef</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">CGImageGetHeight</span><span class="p">(</span><span class="n">originImageRef</span><span class="p">)</span> <span class="o">-</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">));</span>
</span><span class='line'>  <span class="n">CGFloat</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">640</span><span class="p">;</span>
</span><span class='line'>  <span class="n">CGFloat</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">640</span><span class="p">;</span>
</span><span class='line'>  <span class="n">CGFloat</span> <span class="n">blockWidth</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">;</span>
</span><span class='line'>  <span class="n">CGFloat</span> <span class="n">blockHeight</span> <span class="o">=</span> <span class="n">height</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 2 create image blocks</span>
</span><span class='line'>  <span class="n">CGImageRef</span> <span class="o">*</span><span class="n">imagesRefs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">25</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CGImageRef</span><span class="p">));</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">CGRect</span> <span class="n">alphabetRect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">blockWidth</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">blockHeight</span><span class="p">,</span> <span class="n">blockWidth</span><span class="p">,</span> <span class="n">blockHeight</span><span class="p">);</span>
</span><span class='line'>          <span class="n">CGImageRef</span> <span class="n">alphabetImageRef</span> <span class="o">=</span> <span class="n">CGImageCreateWithImageInRect</span><span class="p">(</span><span class="n">alphabetsRegionImageRef</span><span class="p">,</span> <span class="n">alphabetRect</span><span class="p">);</span>
</span><span class='line'>          <span class="n">imagesRefs</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphabetImageRef</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 3 transform to binaryImage</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">CGImageRef</span> <span class="n">binaryImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">createBinaryCGImageFromCGImage:</span><span class="n">imagesRefs</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
</span><span class='line'>      <span class="n">CGImageRelease</span><span class="p">(</span><span class="n">imagesRefs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>      <span class="n">imagesRefs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">binaryImage</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 4</span>
</span><span class='line'>  <span class="n">_needProcessImage</span> <span class="o">=</span> <span class="n">imagesRefs</span><span class="p">;</span>
</span><span class='line'>  <span class="n">CGImageRelease</span><span class="p">(</span><span class="n">alphabetsRegionImageRef</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>我们观察游戏截图，发现字母所在的区域在下方的640 * 640。我们使用<code>CGImageCreateWithImageInRect</code>函数创建了<code>alphabetsRegionImageRef</code>。注意：你需要使用<code>CGImageRelease</code>来release这个对象（函数最后一行），而<code>originImageRef</code>是由<code>UIImage</code>的<code>CGImage</code>方法获得的，你并不持有它，故而不需要release。</li>
<li>我们把<code>alphabetsRegionImageRef</code>裁剪成了25个小的方块，暂时存在<code>imagesRefs</code>数组。</li>
<li>彩色图片包含的信息太多，为了方便我们后续的处理，我们将得到的字母小方块进行二值化。注意：这里我们使用了自定义的函数<code>createBinaryCGImageFromCGImage</code>创建了一个二值化的image，再将其替换到数组里前，需要将数组里存在的旧对象release。</li>
<li>最后我们将<code>imagesRefs</code>赋值给<code>_needProcessImage</code>，并release不需要imageRef。</li>
</ol>


<p>再来看如何进行图像二值化，先将这几个常数加到<code>initWithImage:</code>方法的上面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">RED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">GREEN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">BLUE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">ALPHA</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后来实现<code>createBinaryCGImageFromCGImage</code>方法，从这里开始我们将涉及到像素的操作:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CGImageRef</span><span class="p">)</span><span class="nf">createBinaryCGImageFromCGImage:</span><span class="p">(</span><span class="n">CGImageRef</span><span class="p">)</span><span class="nv">imageRef</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">NSInteger</span> <span class="n">width</span> <span class="o">=</span> <span class="n">CGImageGetWidth</span><span class="p">(</span><span class="n">imageRef</span><span class="p">);</span>
</span><span class='line'>  <span class="n">NSInteger</span> <span class="n">height</span> <span class="o">=</span> <span class="n">CGImageGetHeight</span><span class="p">(</span><span class="n">imageRef</span><span class="p">);</span>
</span><span class='line'>  <span class="n">CGRect</span> <span class="n">imageRect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 1</span>
</span><span class='line'>  <span class="n">UInt32</span> <span class="o">*</span><span class="n">pixels</span> <span class="o">=</span> <span class="p">(</span><span class="n">UInt32</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UInt32</span><span class="p">));</span>
</span><span class='line'>  <span class="n">CGColorSpaceRef</span> <span class="n">colorSpace</span> <span class="o">=</span> <span class="n">CGColorSpaceCreateDeviceRGB</span><span class="p">();</span>
</span><span class='line'>  <span class="n">CGContextRef</span> <span class="n">contextA</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">width</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UInt32</span><span class="p">),</span> <span class="n">colorSpace</span><span class="p">,</span> <span class="n">kCGBitmapByteOrder32Big</span> <span class="o">|</span> <span class="n">kCGImageAlphaPremultipliedLast</span><span class="p">);</span>
</span><span class='line'>  <span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">contextA</span><span class="p">,</span> <span class="n">imageRect</span><span class="p">,</span> <span class="n">imageRef</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 2</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">UInt8</span> <span class="o">*</span><span class="n">rgbaPixel</span> <span class="o">=</span> <span class="p">(</span><span class="n">UInt8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pixels</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">x</span><span class="p">];</span>
</span><span class='line'>          <span class="n">NSInteger</span> <span class="n">r</span> <span class="o">=</span> <span class="n">rgbaPixel</span><span class="p">[</span><span class="n">RED</span><span class="p">];</span>
</span><span class='line'>          <span class="n">NSInteger</span> <span class="n">g</span> <span class="o">=</span> <span class="n">rgbaPixel</span><span class="p">[</span><span class="n">GREEN</span><span class="p">];</span>
</span><span class='line'>          <span class="n">NSInteger</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rgbaPixel</span><span class="p">[</span><span class="n">BLUE</span><span class="p">];</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">g</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">rgbaPixel</span><span class="p">[</span><span class="n">RED</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
</span><span class='line'>              <span class="n">rgbaPixel</span><span class="p">[</span><span class="n">GREEN</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
</span><span class='line'>              <span class="n">rgbaPixel</span><span class="p">[</span><span class="n">BLUE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">rgbaPixel</span><span class="p">[</span><span class="n">RED</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>              <span class="n">rgbaPixel</span><span class="p">[</span><span class="n">GREEN</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>              <span class="n">rgbaPixel</span><span class="p">[</span><span class="n">BLUE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 3</span>
</span><span class='line'>  <span class="n">CGImageRef</span> <span class="n">result</span> <span class="o">=</span> <span class="n">CGBitmapContextCreateImage</span><span class="p">(</span><span class="n">contextA</span><span class="p">);</span>
</span><span class='line'>  <span class="n">CGContextRelease</span><span class="p">(</span><span class="n">contextA</span><span class="p">);</span>
</span><span class='line'>  <span class="n">CGColorSpaceRelease</span><span class="p">(</span><span class="n">colorSpace</span><span class="p">);</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">pixels</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>使用<code>CGBitmapContextCreate</code>创建了一个 bitmap graphics context，并将 pixels 设为其 data pointer，再将 image 绘制到 context 上，这样我们可以通过操作 pixels 来直接操作 context 的数据。该方法的其他参数可以参考文档，参数会影响数据，在这里请先使用我提供的参数。</li>
<li>我们遍历了图像的每个像素点对每个点进行二值化，二值化有许多种算法，大体分为固定阀值和自适应阀值两类。这里我们观察待处理图片可知，我们需要提取的字母部分是明显的黑色，这样使用固定的阀值255，即可顺利将其提取，而有颜色的部分会被剔除。</li>
<li>使用<code>CGBitmapContextCreateImage</code>来从context创建处理后的图片，并清理数据。</li>
</ol>


<p>注意：由于c没有autorelease池，你应当在函数（方法）的命名上使用create(或copy)来提醒使用者应当负责 release 对象。</p>

<p>至此，我们已经完成了字母方块的提取和二值化。为了防止我们没出问题，来检查一下成果。</p>

<ol>
<li>将一张游戏截图&#8221;sample.png&#8221;拖进Xcode proj内。</li>
<li>在<code>CYViewController</code>的<code>viewDidLoad</code>里使用该图片实例化一个<code>CYLetterManager</code>。</li>
<li>在<code>CYLetterManager</code>的<code>getNeedProcessImages</code>里的任意地方加上断点，可以是二值化前后，也可以是切小字母块前后。</li>
<li>运行！然后隆重介绍Xcode5的新功能之一，快速预览，当当当当！</li>
</ol>


<p>以本文最开始的截图为例：</p>

<p><img src="/assets/post/wordhacker2.png" alt="image" /></p>

<p>可以看到我们已经成功的截出了第一个字母，并把其转为二值化图片。</p>

<h2>下一步</h2>

<p>载入了需要的图片和进行了预处理之后，我们来进行识别的前奏：获得识别用的样本。为此我们实现 <code>trainingWihtAlphabets</code> 方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">trainingWihtAlphabets:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">array</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>          <span class="p">[</span><span class="n">self</span> <span class="nl">writeImage:</span><span class="n">_needProcessImage</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="nl">withAlphabet:</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span> <span class="n">prepareTagImageRefs</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>该方法接受一个字母数组，里面应该包含着，我们之前载入图片里的，从左到右，从上到下的字母队列。比如<code>@[@"t", @"e", @"j", ... , @"h"]</code>;</p>

<p>我们使用 <code>writeImage:withAlphabet:</code> 方法，将该图片设为标准样本，写入到文件中。读写 <code>CGImageRef</code> 的方法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="err">@</span><span class="n">import</span> <span class="n">ImageIO</span><span class="p">;</span>
</span><span class='line'><span class="err">@</span><span class="n">import</span> <span class="n">MobileCoreServices</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">pathStringWithAlphabet:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">alphabet</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">imageName</span> <span class="o">=</span> <span class="p">[</span><span class="n">alphabet</span> <span class="nl">stringByAppendingString:</span><span class="s">@&quot;.png&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">documentsPath</span> <span class="o">=</span> <span class="p">[</span><span class="s">@&quot;~/Documents&quot;</span> <span class="n">stringByExpandingTildeInPath</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">documentsPath</span> <span class="nl">stringByAppendingString:</span><span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;/%@&quot;</span><span class="p">,</span> <span class="n">imageName</span><span class="p">]];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">path</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CGImageRef</span><span class="p">)</span><span class="nf">createImageWithAlphabet:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">alphabet</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">pathStringWithAlphabet:</span><span class="n">alphabet</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGImageRef</span> <span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">createImageFromFile:</span><span class="n">path</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">image</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CGImageRef</span><span class="p">)</span><span class="nf">createImageFromFile:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">path</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CFURLRef</span> <span class="n">url</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">CFURLRef</span><span class="p">)[</span><span class="n">NSURL</span> <span class="nl">fileURLWithPath:</span><span class="n">path</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGDataProviderRef</span> <span class="n">dataProvider</span> <span class="o">=</span> <span class="n">CGDataProviderCreateWithURL</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGImageRef</span> <span class="n">image</span> <span class="o">=</span> <span class="n">CGImageCreateWithPNGDataProvider</span><span class="p">(</span><span class="n">dataProvider</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">NO</span><span class="p">,</span> <span class="n">kCGRenderingIntentDefault</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGDataProviderRelease</span><span class="p">(</span><span class="n">dataProvider</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">image</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">writeImage:</span><span class="p">(</span><span class="n">CGImageRef</span><span class="p">)</span><span class="nv">imageRef</span> <span class="nf">withAlphabet:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">alphabet</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">pathStringWithAlphabet:</span><span class="n">alphabet</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">writeImage:</span><span class="n">imageRef</span> <span class="nl">toFile:</span><span class="n">path</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">writeImage:</span><span class="p">(</span><span class="n">CGImageRef</span><span class="p">)</span><span class="nv">imageRef</span> <span class="nf">toFile:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">path</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CFURLRef</span> <span class="n">url</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">CFURLRef</span><span class="p">)[</span><span class="n">NSURL</span> <span class="nl">fileURLWithPath:</span><span class="n">path</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGImageDestinationRef</span> <span class="n">destination</span> <span class="o">=</span> <span class="n">CGImageDestinationCreateWithURL</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">kUTTypePNG</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGImageDestinationAddImage</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">imageRef</span><span class="p">,</span> <span class="nb">nil</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CGImageDestinationFinalize</span><span class="p">(</span><span class="n">destination</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Failed to write image to %@&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">destination</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>prepareTagImageRefs</code> 方法将磁盘里保存的样本图片摘出来，存在_tagImageRefs数组里面，用于之后的比对。实现如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">prepareTagImageRefs</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">_tagImageRefs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">26</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CGImageRef</span><span class="p">));</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="n">NSString</span> <span class="o">*</span><span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%c&quot;</span><span class="p">,</span> <span class="n">ch</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_tagImageRefs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">createImageWithAlphabet:</span><span class="n">alpha</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">_tagImageRefs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Need sample: %c&quot;</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>将 <code>[self prepareTagImageRefs]</code> 加到 <code>initWitImage:</code> 方法里面，这样我们每次实例化的时候，都会自动从磁盘里读取标记好的样本图片。</p>

<p><strong>非常需要注意的是</strong>：我们添加dealloc方法（用惯了arc的开发者可能会不习惯），但这是c，是需要我们自己管理内存的。在dealloc里面释放我们的成员变量吧：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">_tagImageRefs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CGImageRelease</span><span class="p">(</span><span class="n">_tagImageRefs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">_tagImageRefs</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CGImageRelease</span><span class="p">(</span><span class="n">_needProcessImage</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">_needProcessImage</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来，我们需要载入足够多的包含了26个英文字母的sample图片，做好训练，将26个样品图片就都裁剪好的存入磁盘啦！（哥哥写不动了，训练代码在CYViewController里面，翻到最下面看源码啦）</p>

<h2>识别字母！</h2>

<p>OCR技术从最早的模式匹配，到现在流行的特征提取，有各种各样的方法。我们这里不搞那么复杂，而使用最简单粗暴的像素比对。即我们之前将其转化为二值化图像了之后，直接比对两个图片相同的像素点比例即可。</p>

<p>我们使用标记过的<code>_tagImageRefs</code>作为比对样本，将要识别的图像与26个标准样本进行比对，当相似度大于某个阀值的时候，我们即判定其为某个字母，实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">ocrCGImage:</span><span class="p">(</span><span class="n">CGImageRef</span><span class="p">)</span><span class="nv">imageRef</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSInteger</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CGImageRef</span> <span class="n">tagImage</span> <span class="o">=</span> <span class="n">_tagImageRefs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">tagImage</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CGFloat</span> <span class="n">similarity</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">similarityBetweenCGImage:</span><span class="n">imageRef</span> <span class="nl">andCGImage:</span><span class="n">tagImage</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">similarity</span> <span class="o">&gt;</span> <span class="mf">0.92</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">result</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>                <span class="k">break</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>        <span class="n">NSString</span> <span class="o">*</span><span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%c&quot;</span><span class="p">,</span> <span class="n">ch</span><span class="p">];</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">alpha</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// suppose imageRefA has same size with imageRefB</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">similarityBetweenCGImage:</span><span class="p">(</span><span class="n">CGImageRef</span><span class="p">)</span><span class="nv">imageRefA</span> <span class="nf">andCGImage:</span><span class="p">(</span><span class="n">CGImageRef</span><span class="p">)</span><span class="nv">imageRefB</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">similarity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSInteger</span> <span class="n">width</span> <span class="o">=</span> <span class="n">CGImageGetWidth</span><span class="p">(</span><span class="n">imageRefA</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSInteger</span> <span class="n">height</span> <span class="o">=</span> <span class="n">CGImageGetHeight</span><span class="p">(</span><span class="n">imageRefA</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGRect</span> <span class="n">imageRect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UInt32</span> <span class="o">*</span><span class="n">pixelsOfImageA</span> <span class="o">=</span> <span class="p">(</span><span class="n">UInt32</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UInt32</span><span class="p">));</span>
</span><span class='line'>    <span class="n">UInt32</span> <span class="o">*</span><span class="n">pixelsOfImageB</span> <span class="o">=</span> <span class="p">(</span><span class="n">UInt32</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UInt32</span><span class="p">));</span>
</span><span class='line'>    <span class="n">CGColorSpaceRef</span> <span class="n">colorSpace</span> <span class="o">=</span> <span class="n">CGColorSpaceCreateDeviceRGB</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CGContextRef</span> <span class="n">contextA</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="n">pixelsOfImageA</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">width</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UInt32</span><span class="p">),</span> <span class="n">colorSpace</span><span class="p">,</span> <span class="n">kCGBitmapByteOrder32Big</span> <span class="o">|</span> <span class="n">kCGImageAlphaPremultipliedLast</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGContextRef</span> <span class="n">contextB</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="n">pixelsOfImageB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">width</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UInt32</span><span class="p">),</span> <span class="n">colorSpace</span><span class="p">,</span> <span class="n">kCGBitmapByteOrder32Big</span> <span class="o">|</span> <span class="n">kCGImageAlphaPremultipliedLast</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">contextA</span><span class="p">,</span> <span class="n">imageRect</span><span class="p">,</span> <span class="n">imageRefA</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">contextB</span><span class="p">,</span> <span class="n">imageRect</span><span class="p">,</span> <span class="n">imageRefB</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSInteger</span> <span class="n">similarPixelCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSInteger</span> <span class="n">allStrokePixelCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">UInt8</span> <span class="o">*</span><span class="n">rgbaPixelA</span> <span class="o">=</span> <span class="p">(</span><span class="n">UInt8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pixelsOfImageA</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">x</span><span class="p">];</span>
</span><span class='line'>            <span class="n">UInt8</span> <span class="o">*</span><span class="n">rgbaPixelB</span> <span class="o">=</span> <span class="p">(</span><span class="n">UInt8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pixelsOfImageB</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">x</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">rgbaPixelA</span><span class="p">[</span><span class="n">RED</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">allStrokePixelCount</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">rgbaPixelA</span><span class="p">[</span><span class="n">RED</span><span class="p">]</span> <span class="o">==</span> <span class="n">rgbaPixelB</span><span class="p">[</span><span class="n">RED</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">similarPixelCount</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">similarity</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="n">similarPixelCount</span> <span class="o">/</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="n">allStrokePixelCount</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGColorSpaceRelease</span><span class="p">(</span><span class="n">colorSpace</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGContextRelease</span><span class="p">(</span><span class="n">contextA</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGContextRelease</span><span class="p">(</span><span class="n">contextB</span><span class="p">);</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">pixelsOfImageA</span><span class="p">);</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">pixelsOfImageB</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">similarity</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了上面两个识别的方法，我们再实现<code>ocrAlphabets</code>方法就很容易了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">ocrAlphabets</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">alphabets</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nl">arrayWithCapacity:</span><span class="mi">25</span><span class="p">];</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSString</span> <span class="o">*</span><span class="n">alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">ocrCGImage:</span><span class="n">_needProcessImage</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">alphabet</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">alphabets</span> <span class="nl">addObject:</span><span class="n">alphabet</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">alphabets</span> <span class="nl">addObject:</span><span class="s">@&quot;unknown&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">alphabets</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>开始拼词</h2>

<p>首先，我们需要准备一个词典。你可以在Unix（或者Unix-like）的系统里找到words.txt这个文件，他一般存在 <code>/usr/share/dict/words, or /usr/dict/words</code></p>

<p>将这个文件拷贝出来，并添加到我们的工程里。我们将创建一个 <code>CYWordHacker</code> 类来做拼词的事情，实现传入一组字符，返回所有合法单词按长度降序排列的数组的接口，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">@interface</span> <span class="nc">CYWordHacker</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">getAllValidWordWithAlphabets:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">alphabets</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>具体实现从略，可参照源码。</p>

<h2>界面</h2>

<p>做成下面这样就可以了：</p>

<p><img src="/assets/post/wordhacker3.png" alt="image" /></p>

<p>界面细节大家就去看源码吧~写不动了~哥哥要和猫咪玩乐去了~</p>

<h2>最终成品</h2>

<p>全部的代码在Github开源托管：<a href="https://github.com/lancy/letterfun">点这里</a></p>

<p><img src="/assets/post/wordhacker4.png" alt="Drawing" style="width: 200px;"/>
<img src="/assets/post/wordhacker5.png" alt="Drawing" style="width: 200px;"/></p>

<h2>还有一件事</h2>

<p>这个东西其实到这里并不是就完了，我们将图片二值化后其实去掉了图片的很多信息，比如当前游戏的状态。有兴趣的筒子，可以根据字块的颜色，来识别出游戏的状态，写出更智能更强力拼词器。实现诸如：占有更多对方的格子或者做出最大的block区域等强力功能，甚至求出最优解策略。这就涉及到人工智能的领域啦。</p>

<h2>联系我</h2>

<ul>
<li>写邮件：lancy1014#gmail.com</li>
<li>关注我的<a href="http://weibo.com/lancy1014/">微博</a></li>
<li>Fo我的<a href="http://github.com/lancy">Github</a></li>
<li>在这里写评论留言</li>
</ul>


<p>Lancy</p>

<p>20 Oct.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-10-19T00:00:00+08:00" pubdate data-updated="true">Oct 19<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>


</div>
	
	<div class="comments"><a href="/blog/2013/10/19/WordHacker/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/09/27/bitwise-operation-in-cocoa/">
		
			Cocoa中的位与位运算</a>
	</h2>
	<div class="entry-content">
		<h2>介绍</h2>

<p>位操作是程序设计中对位模式或二进制数的一元和二元操作. 在许多古老的微处理器上, 位运算比加减运算略快, 通常位运算比乘除法运算要快很多. 在现代架构中, 情况并非如此:位运算的运算速度通常与加法运算相同(仍然快于乘法运算).（摘自wikipedia）</p>

<p>OC作为c的扩展和超集，位运算自然使用的是c的操作符。c提供了6个位操作符，$，|，^，~，&lt;&lt;，>>。本文不打算做位运算的基础教学，只介绍一些开发中能用到的场景。</p>

<h2>提高运算速度</h2>

<p>如前一段所说，位运算的运算速度是通常与加法速度相当，但是快于乘法运算的。故而如果我们的程序对性能有要求，我们可以使用位运算来提高运算速度。比如：</p>

<ul>
<li>乘以2：n &lt;&lt; 1;</li>
<li>除以2：n >> 1;</li>
<li>乘以2的m次方：n &lt;&lt; m;</li>
<li>除以2的m次方：n >> m;</li>
<li>判断奇偶：(n &amp; 1) == 1;</li>
<li>求平均数：(a + b) >> 1;</li>
<li>&hellip;&hellip;</li>
</ul>


<p>基于乘除法的位运算提速还有很多，这里不一一列举。需要注意的是，你应当只在遇到性能瓶颈的时候，并且瓶颈的确是计算的时候才这么做。因为使用位运算并不利于程序的可读性和可维护性。（科学计算除外）</p>

<h2>压缩空间</h2>

<p>以前接触过ACM的筒子们应该对状态压缩不陌生，状态压缩的目的在于把一个大数据用有限的内存空间来进行表示。比如 Programming Pearls 里面的一个经典示例：如何对最多有一千万条不重复的7位整数（电话号码）进行排序？且可使用的内存空间有大约1MB多。</p>

<p>显而易见的常规做法既是做一个基于磁盘操作的外排序。然而如果转换一下思路，充分的使用内存中的每一个位，加上不存在重复的电话号码，以及不存在0和1开头的电话号码。我们只需要使用1000万个位（大约1.2mb），就能以集合的方式在内存里标记下所有的数据，从而轻松的实现位排序。此种方法大幅度的减少了IO时间，从而获得巨大的性能提升。</p>

<p>ACM里面有大量的如果使用位来压缩空间的示例，状态压缩的动态规划等，此处不做展开，只告诉读者，充分的使用内存的每一个位，经常能带来意想不到的收获。但需要注意的是，状态的压缩和提取，都需要一定的计算量，有时一味的追求状态压缩，反而会降低效率。</p>

<h2>表示数据</h2>

<p>比较经典的一个应用场景，使用一串24位的十六机制数字来表现一个RGB颜色（或者32位来表示ARGB）。由于PS，Web以及各类取色器，都能快速的取出RGB的Hex值，但是UIColor没有对应的方法。故而我们可以写出下面这样一个UIColor的Category，来快速的用一个RGBHex生成一个UIColor。（源码在<a href="http://github.com/lancy/cyhelper">UIColor + CYHelper.h</a>）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nf">colorWithRGBHex:</span><span class="p">(</span><span class="n">UInt32</span><span class="p">)</span><span class="nv">hex</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithRGBHex:</span><span class="n">hex</span> <span class="nl">alpha:</span><span class="mf">1.0f</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nf">colorWithRGBHex:</span><span class="p">(</span><span class="n">UInt32</span><span class="p">)</span><span class="nv">hex</span> <span class="nf">alpha:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">alpha</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">hex</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">hex</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">hex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithRed:</span><span class="n">r</span> <span class="o">/</span> <span class="mf">255.0f</span> <span class="nl">green:</span><span class="n">g</span> <span class="o">/</span> <span class="mf">255.0f</span> <span class="nl">blue:</span><span class="n">b</span> <span class="o">/</span> <span class="mf">255.0f</span> <span class="nl">alpha:</span><span class="n">alpha</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>状态与选项</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">typedef</span> <span class="nf">NS_OPTIONS</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">,</span> <span class="n">UIViewAnimationOptions</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionLayoutSubviews</span>            <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionAllowUserInteraction</span>      <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">1</span><span class="p">,</span> <span class="c1">// turn on user interaction while animating</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionBeginFromCurrentState</span>     <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">2</span><span class="p">,</span> <span class="c1">// start all views from current value, not initial value</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionRepeat</span>                    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">3</span><span class="p">,</span> <span class="c1">// repeat animation indefinitely</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionAutoreverse</span>               <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">4</span><span class="p">,</span> <span class="c1">// if repeat, run animation back and forth</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionOverrideInheritedDuration</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">5</span><span class="p">,</span> <span class="c1">// ignore nested duration</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionOverrideInheritedCurve</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">6</span><span class="p">,</span> <span class="c1">// ignore nested curve</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionAllowAnimatedContent</span>      <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">7</span><span class="p">,</span> <span class="c1">// animate contents (applies to transitions only)</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionShowHideTransitionViews</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">,</span> <span class="c1">// flip to/from hidden state instead of adding/removing</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionOverrideInheritedOptions</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span>  <span class="mi">9</span><span class="p">,</span> <span class="c1">// do not inherit any options or animation type</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UIViewAnimationOptionCurveEaseInOut</span>            <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">,</span> <span class="c1">// default</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionCurveEaseIn</span>               <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionCurveEaseOut</span>              <span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionCurveLinear</span>               <span class="o">=</span> <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UIViewAnimationOptionTransitionNone</span>            <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span> <span class="c1">// default</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionTransitionFlipFromLeft</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionTransitionFlipFromRight</span>   <span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionTransitionCurlUp</span>          <span class="o">=</span> <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionTransitionCurlDown</span>        <span class="o">=</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionTransitionCrossDissolve</span>   <span class="o">=</span> <span class="mi">5</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionTransitionFlipFromTop</span>     <span class="o">=</span> <span class="mi">6</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
</span><span class='line'>    <span class="n">UIViewAnimationOptionTransitionFlipFromBottom</span>  <span class="o">=</span> <span class="mi">7</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span> <span class="n">NS_ENUM_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">4</span><span class="n">_0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们观察Apple在UIViewAnimationOptions的枚举变量，使用了一个NSUInteger就表示了UIViewAnimation所需的所有Option。其中0~9十个是互不影响的可同时存在option。16~19，20~24使用了4位来表示互斥的option。</p>

<p>如此定义了之后，对UIViewAnimationOptions的赋值变得尤为简单，使用 | 操作符既可以获得一个给对应的option位赋值后的结果。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="mf">1.0</span>
</span><span class='line'>                      <span class="nl">delay:</span><span class="mi">0</span>
</span><span class='line'>                    <span class="nl">options:</span><span class="n">UIViewAnimationOptionAllowUserInteraction</span>
</span><span class='line'>                         <span class="o">|</span> <span class="n">UIViewAnimationOptionBeginFromCurrentState</span>
</span><span class='line'>                         <span class="o">|</span> <span class="n">UIViewAnimationOptionCurveEaseIn</span>
</span><span class='line'>                 <span class="nl">animations:</span><span class="p">{...}</span>
</span><span class='line'>                 <span class="nl">completion:</span><span class="p">{...}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>提取也比较简单，使用 &amp; 操作符 和 >> 操作符，就可以轻松判定某个位有没有被设置，以及提取某些状态位，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">UIViewAnimationOptions</span> <span class="n">option</span> <span class="o">=</span> <span class="n">UIViewAnimationOptionAllowUserInteraction</span>
</span><span class='line'>                                <span class="o">|</span> <span class="n">UIViewAnimationOptionBeginFromCurrentState</span>
</span><span class='line'>                                <span class="o">|</span> <span class="n">UIViewAnimationOptionCurveEaseIn</span>
</span><span class='line'>                                <span class="o">|</span> <span class="n">UIViewAnimationOptionTransitionCrossDissolve</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">option</span> <span class="o">&amp;</span> <span class="n">UIViewAnimationOptionAllowUserInteraction</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;UIViewAnimationOptionAllowUserInteraction has been set&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">option</span> <span class="o">&amp;</span> <span class="n">UIViewAnimationOptionBeginFromCurrentState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;UIViewAnimationOptionBeginFromCurrentState has been set&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">UInt8</span> <span class="n">optionCurve</span> <span class="o">=</span> <span class="n">option</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">optionCurve</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;UIViewAnimationOptionCurveEaseIn has been set&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">UInt8</span> <span class="n">optionTransition</span> <span class="o">=</span> <span class="n">option</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">optionTransition</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;UIViewAnimationOptionTransitionCrossDissolve has been set&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里最需要注意的地方就是，对互斥的状态的设置必须尤为小心，如果你这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">UIViewAnimationOptions</span> <span class="n">badOption</span> <span class="o">=</span> <span class="n">UIViewAnimationOptionCurveEaseIn</span> <span class="o">|</span> <span class="n">UIViewAnimationOptionCurveEaseOut</span><span class="p">;</span>
</span><span class='line'><span class="n">UInt8</span> <span class="n">oops</span> <span class="o">=</span> <span class="n">badOption</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Sorry, it&#39;s not UIViewAnimationOptionCurveEaseInOut&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;oops = %d, you got UIViewAnimationOptionCurveLinear&quot;</span><span class="p">,</span> <span class="n">oops</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>联系我</h2>

<ul>
<li>写邮件：lancy1014#gmail.com</li>
<li>关注我的<a href="http://weibo.com/lancy1014/">微博</a></li>
<li>Fo我的<a href="http://github.com/lancy">Github</a></li>
<li>在这里写评论留言</li>
</ul>


<p>Lancy</p>

<p>9.27</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-09-27T00:00:00+08:00" pubdate data-updated="true">Sep 27<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/blog/2013/09/27/bitwise-operation-in-cocoa/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/08/11/make-your-own-cocoapods-spec/">
		
			制作自己的CocoaPods Spec</a>
	</h2>
	<div class="entry-content">
		<h2>前言</h2>

<p>关于CocoaPods，相信不用我介绍更多了。本文主要介绍如何制作自己的CocoaPods spec。</p>

<h2>步骤</h2>

<ol>
<li>首先你要会用git，还要有一个托管在云端的repo，本文以Github为例，Git和Github的使用方式参照<a href="http://github.com/help">Github Help</a></li>
<li><p>在你的repo下面，使用Git的tag功能，给你的某个commit添加一个tag(比如1.1.0），并push到Github.</p>

<pre><code> // 本地添加一个标签:
 $ git tag -a 1.1.0 -m "Version 1.1.0 Stable"
 // Push tag to GitHub:
 $ git push --tags
</code></pre></li>
<li><p>Folk <a href="https://github.com/CocoaPods/Specs">CocoaPods/Specs</a> 并 Clone 到本地。</p></li>
<li><p>在Clone下来的Specs/创建一个自己的spec的目录，再创建一个版本目录。比如：</p>

<pre><code> Specs/CYHelper/1.1.0
</code></pre></li>
<li><p>在该目录下创建一个spec档案，并编辑：</p>

<pre><code> $ pod spec create CYHelper
 $ vi CYHelper.podspec
</code></pre>

<p> pod创建模板会有相关的说明，按指引一步一步填即可。例如，CYHelper的spec配置如下:</p>

<pre><code> Pod::Spec.new do |s|
   s.name         = "CYHelper"
   s.version      = "1.1.0"
   s.summary      = "CYHelper is an Objective-C library for iOS developers."
   s.homepage     = "https://github.com/lancy/CYHelper"
   s.license      = 'MIT (LICENSE)'
   s.author       = { "lancy" =&gt; "lancy1014@gmail.com" }
   s.source       = { :git =&gt; "https://github.com/lancy/CYHelper.git", :tag =&gt; "1.1.0" }
   s.platform     = :ios, '5.0'

   s.source_files = 'CYHelper', 'CYHelper/**/*.{h,m}'
   s.exclude_files = 'CYHelperDemo'

   s.frameworks = 'Foundation', 'CoreGraphics', 'UIKit'
   s.requires_arc = true
 end
</code></pre></li>
<li><p>验证podspec</p>

<pre><code> pod spec lint CYHelper.podspec        
</code></pre>

<p> 如果验证成功的话，会有这样的提示</p>

<pre><code> Analyzed 1 podspec.

 CYHelper.podspec passed validation.
</code></pre></li>
<li><p>最后去Github上发一个PullRequest，等待一段时间的审核和Merge，之后就可以像别的pod那样用CocoaPods来管理了：</p>

<pre><code> // Podfile
 platform :ios, '6.0'
 pod 'CYHelper' 

 $ pod install       
</code></pre></li>
</ol>


<p>Have Fun!</p>

<h2>后注</h2>

<ul>
<li><a href="https://github.com/lancy/cyhelper">CYHelper在这里，欢迎试用</a></li>
<li><a href="https://github.com/lancy">顺便求fo我的github</a></li>
</ul>


<p>这里有唐巧和王轲写的两篇相关的文章，可以作为扩展阅读：</p>

<ul>
<li><a href="http://blog.devtang.com/blog/2012/12/02/use-cocoapod-to-manage-ios-lib-dependency/">使用CocoaPods来做iOS程序的包依赖管理</a></li>
<li><a href="http://www.iwangke.me/2013/04/18/advanced-cocoapods/">CocoaPods进阶：本地包管理</a></li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-08-11T00:00:00+08:00" pubdate data-updated="true">Aug 11<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/blog/2013/08/11/make-your-own-cocoapods-spec/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/06/04/singletons-in-cocoa-are-they-evil/">
		
			Singletons in Cocoa, Are They Evil?</a>
	</h2>
	<div class="entry-content">
		<h2>故事</h2>

<p>这事是这样的，去年我在上课的时候，和老师讨论了一下关于架构的问题，我是开发Cocoa/iOS的，老师是开发Web的，而老师是一个坚定的singletons are evil的拥护者，我和他说了我的App的架构，直接被他一顿猛劈，强烈的谴责了我使用Singletons，我回应说，这个pattern在Cocoa里是大量使用的，结果被搞了一句“用的多的就是对的么？你回去多学习一下再来讨论吧”。</p>

<p>于是我非常郁闷的回去搜索的一大顿的资料，还在Stackoverflow上发起了一个问题：<a href="http://stackoverflow.com/questions/13306268/singletons-in-cocoa-are-they-evil">singletons in cocoa, are they evil?</a>。甚至在某个社区，假扮singleton are evil的拥护者，把所有singleton的缺点列了一堆，结果又是群起而攻之一场舌战。</p>

<p>关于Singleton的缺点，放出一段引用：</p>

<blockquote><ol>
<li><p>They are generally used as a global instance, why is that so bad? Because you hide the dependencies of your application in your code, instead of exposing them through the interfaces. Making something global to avoid passing it around is a code smell.</p></li>
<li><p>They violate the Single Responsibility Principle: by virtue of the fact that they control their own creation and lifecycle.</p></li>
<li><p>They inherently cause code to be tightly coupled. This makes faking them out under test rather difficult in many cases.</p></li>
<li><p>They carry state around for the lifetime of the app. Another hit to testing since you can end up with a situation where tests need to be ordered which is a big no no for unit tests. Why? Because each unit test should be independent from the other.</p></li>
</ol>
</blockquote>

<p>公说公有理，婆说婆有理，一度把我弄得越来越困惑，后来我看到这一段话，我就彻底释然了：</p>

<blockquote><p>As for degrees of evil &ndash; it&rsquo;s like speech or literature. F-words are &ldquo;evil&rdquo;. If you speak constantly using f-words words the quality of your language is lower &ndash; people can&rsquo;t tell if you want to say something or just swearing. But in some situations such words help you to get things done (think of the battlefield orders). It sort of the same thing with features/patterns and people who have to read and maintain their usage.</p>

<p>– hoha</p></blockquote>

<p>BTW，今天我甚至看到了<a href="http://c2.com/cgi/wiki?AccessorsAreEvil">Accessors Are Evil</a>这样的东西，更坚定了我再也不相信xxx are evil这种说法的决心。</p>

<p>我现在认为Design pattern是前人总结的经验，不同的设计模式有不同的优缺点，比如说用工厂代替单例的，虽说解决了单例的一些问题，但你要真去写一个工厂就知道有多蛋疼，多浪费生命了。然而在较为大型的应用，非常多人协作的项目，队友对项目的把握不一致，水平有高低之分，这时工厂又反而是一种安全的，省时省力的做法。</p>

<p>其实在代码的世界里面，你想要更多的安全，就会丧失更多的灵活性和便利性。如何在这中间取舍，就需要我们彻底的了解某种模式（或者说某种编程方法）的优缺点，在保证基本的安全性的情况下，尽可能的减少工作量，提高工作效率。</p>

<h2>Singletons in Cocoa</h2>

<p>回到正题，还是来说说Cocoa上的单例。Cocoa中的普遍的，大部分的单例，并不是严格的单例（strict singleton），而是一种共享单例（shared singleton），例如sharedApplication，sharedURLCache等。即，大多数情况，我们访问同一个类方法，就可以获得一个同样的实例，但若真的需要存在多个实例亦可。通常，共享单例使用一个shared开的类方法识别。只有当真的只有唯一的一个共享资源的时候，或者不可能有多个资源的时候（比如GPS模块），才会使用严格意义的共享单例。</p>

<h2>线程安全的Singleton</h2>

<p>绝大多数情况下，使用一个共享单例比使用共享单例要好，然而这里有一个常见的创建共享单例的错误，即使是Apple自己的开发者文档也没弄清楚的一个错误，他们把Singleton写成了非线程安全的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">MyClass</span> <span class="o">*</span><span class="p">)</span><span class="nf">sharedInstance</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">MyClass</span> <span class="o">*</span><span class="n">sharedInstance</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">sharedInstance</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">sharedInstance</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyClass</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">sharedInstance</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>正确的写法应该是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">MyClass</span> <span class="o">*</span><span class="p">)</span><span class="nf">sharedInstance</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">MyClass</span> <span class="o">*</span><span class="n">sharedInstance</span><span class="p">;</span>
</span><span class='line'>    <span class="k">@synchronized</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">sharedInstance</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">sharedInstance</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyClass</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">sharedInstance</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
更恰当的写法是使用dispatch_once()</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">MYClass</span> <span class="o">*</span><span class="p">)</span><span class="nf">sharedInstance</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">pred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">MYClass</span> <span class="n">_sharedObject</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="n">_sharedObject</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span> <span class="c1">// or some other init method</span>
</span><span class='line'>            <span class="p">});</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_sharedObject</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>dispatch_once()即为执行且仅仅执行某个block一次，他是同步的方法（记住GCD也有很多同步的方法），其速度也比 @synchronized 快许多。</p>

<h2>严格的单例(strict singleton)</h2>

<p>尽管我们很少会使用到严格的单例模式，但当真的需要的时候，还是可以实现的。</p>

<p>苹果官方文档提供了一个严格单例的实现（<a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW32">传送门</a>）。
其重载了allocWithZone:, copyWithZone, retain, retainCount, release, autorelease。使得这个实现变得无比复杂而难以理解和控制。</p>

<p>而大多数情况下，实现严格的单例模式，只需要和共享单例相同的代码，再使用NSAssert使得一切调用init的代码作为一个错误处理即可，代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">MYSingleton</span> <span class="o">*</span><span class="p">)</span><span class="nf">sharedSingleton</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">pred</span><span class="p">;</span>
</span><span class='line'>     <span class="k">static</span> <span class="n">MYSingleton</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>     <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">instance</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initSingleton</span><span class="p">];});</span>
</span><span class='line'>     <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Forbid calls to –init or +new</span>
</span><span class='line'>    <span class="n">NSAssert</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span> <span class="err">@”</span><span class="n">Cannot</span> <span class="n">create</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">Singleton</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// You can return nil or [self initSingleton] here, </span>
</span><span class='line'>    <span class="c1">// depending on how you prefer to fail.</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Real (private) init method</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initSingleton</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">]))</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Init code }</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这份代码的优点是很明显的，避免了复杂的内存操作和重载，又静止了调用者创建多个实例。</p>

<h2>小结</h2>

<p>小结一下，单例模式是Cocoa中非常常用的一个模式，对于应用程序中广泛使用的对象，单例模式是非常便利的方法。而我们也应当在使用的时候多注意单例模式的一些缺点，尽可能的在实现的时候避免他们，比如让单例不存在过于复杂的依赖性和继承，保证其松耦合等。</p>

<h2>Edit:</h2>

<p>One more thing:有筒子问到是@synchronized(self)还是@synchronized(sharedInstance)?</p>

<p>答案是：均可。</p>

<p>self，在实例方法中表现是实例，这一点自不用多说。在类方法中则表现为一种多态的类实例（class instance），他总是会返回正确的类型，比如这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">new</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而在本文的这个@synchronized(self)里的self，总是会指向同一个对象，即那个特殊的类实例。（class也是一个对象），故而此处可以使用self。</p>

<p>lancy</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-06-04T00:00:00+08:00" pubdate data-updated="true">Jun 4<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/blog/2013/06/04/singletons-in-cocoa-are-they-evil/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/06/02/constant-pointer-and-pointer-to-constant/">
		
			OBJC中声明字符串常量的一个常见错误（常量指针和指针常量）</a>
	</h2>
	<div class="entry-content">
		<p>我们知道，NSNotification是Cocoa中观察模式最易用的实现方法，比起直接使用KVO（Key-Value Observing）他更加容易实现也更好理解。一个样例：</p>

<h4>Poster.h</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// Define a string constant for the notification</span>
</span><span class='line'><span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">PosterDidSomethingNotification</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Poster.m</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">PosterDidSomethingNotification</span> <span class="o">=</span> <span class="err">@”</span><span class="n">PosterDidSomethingNotification</span><span class="err">”</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="c1">// Include the poster as the object in the notification</span>
</span><span class='line'><span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span>
</span><span class='line'><span class="nl">postNotificationName:</span><span class="n">PosterDidSomethingNotification</span>
</span><span class='line'>              <span class="nl">object:</span><span class="n">self</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Observer.m</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// Import Poster.h to get the string constant</span>
</span><span class='line'><span class="cp">#import “Poster.h”</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="c1">// Register to receive a notification</span>
</span><span class='line'><span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">addObserver:</span><span class="n">self</span>
</span><span class='line'>                                         <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">posterDidSomething:</span><span class="p">)</span>
</span><span class='line'>                                             <span class="nl">name:</span><span class="n">PosterDidSomethingNotification</span>
</span><span class='line'>                                           <span class="nl">object:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nl">posterDidSomething:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="n">note</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Handle the notification here</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Always remove your observations</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">removeObserver:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">dealloc</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意到，在使用Notifikation的时候，会需要声明字符串常量，作为notification的name。这时，const的位置就比较重要，很容易让不了解的人犯错误：</p>

<p>错误的写法（常量指针）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">extern</span> <span class="k">const</span> <span class="n">NSString</span> <span class="o">*</span> <span class="n">RNFooDidCompleteNotification</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>正确的写法（指针常量）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">RNFooDidCompleteNotification</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里涉及到常量指针和指针常量的概念，简单的来说：</p>

<ul>
<li>常量指针：就是指向常量的指针，关键字 const 出现在 * 左边，表示指针所指向的地址的内容是不可修改的，但指针自身可变。</li>
<li>指针常量：指针自身是一个常量，关键字 const 出现在 * 右边，表示指针自身不可变，但其指向的地址的内容是可以被修改的。</li>
</ul>


<p>在此例中：我们知道，NSString永远是immutable的，所以NSString * const 是有效的，而const NSString * 则是无效的。而使用错误的写法，则无法阻止修改该指针指向的地址，使得本应该是常量的值能被修改，造成了隐患。这是需要注意的一个常见错误。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-06-02T00:00:00+08:00" pubdate data-updated="true">Jun 2<span>nd</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/blog/2013/06/02/constant-pointer-and-pointer-to-constant/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/05/22/objective-c-associative-references-part2/">
		
			Objective-C Associative References(关联引用) 续：相关实践</a>
	</h2>
	<div class="entry-content">
		<h2>About</h2>

<p>我之前写了一篇博文<a href="http://gracelancy.com/?p=82">Objective-C Associative References(关联引用)</a>，介绍我在在研究objc runtime的有趣的发现，但当时我并没有意识到这个技术应该使用在何处。在一些实践之后，小结一下有关关联引用的一些相关实践吧。</p>

<h2>Category中使用关联引用来添加property</h2>

<p>我们知道category是不能创建实例变量的，但我们可以通过关联引用来达到这样的目的。特别是当你不持有这个类，比如说系统的类，而你又的确需要添加一个property。</p>

<p>你可以这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#import &lt;objc/runtime.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Person</span> <span class="nl">(EmailAddress)</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">readwrite</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">emailAddress</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Person</span> <span class="nl">(EmailAddress)</span>
</span><span class='line'><span class="k">static</span> <span class="kt">char</span> <span class="n">emailAddressKey</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">emailAddress</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emailAddressKey</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setEmailAddress:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">emailAddress</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emailAddressKey</span><span class="p">,</span> <span class="n">emailAddress</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_COPY</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>给UI控件关联上相关对象</h2>

<p>比如UIAlert只有一个tag属性用来做标记，我们经常需要根据Tag属性在找出对应需要操作的对象。但使用关联对象，我们可以把UIAlert和某个对象关联，简化这个过程。</p>

<p>比如你可以这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="kt">id</span> <span class="n">interestingObject</span> <span class="o">=</span> <span class="p">...;</span>
</span><span class='line'><span class="n">UIAlertView</span> <span class="o">*</span><span class="n">alert</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAlertView</span> <span class="n">alloc</span><span class="p">]</span>
</span><span class='line'>                     <span class="nl">initWithTitle:</span><span class="err">@”</span><span class="n">Alert</span><span class="err">”</span> <span class="nl">message:</span><span class="nb">nil</span>
</span><span class='line'>                     <span class="nl">delegate:</span><span class="n">self</span>
</span><span class='line'>                     <span class="nl">cancelButtonTitle:</span><span class="err">@”</span><span class="n">OK</span><span class="err">”</span>
</span><span class='line'>                     <span class="nl">otherButtonTitles:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">alert</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kRepresentedObject</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">interestingObject</span><span class="p">,</span>
</span><span class='line'>                     <span class="n">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class="p">);</span>
</span><span class='line'><span class="p">[</span><span class="n">alert</span> <span class="n">show</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在alertView的delegate方法里面这样操作:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">alertView:</span><span class="p">(</span><span class="n">UIAlertView</span> <span class="o">*</span><span class="p">)</span><span class="nv">alertView</span>
</span><span class='line'><span class="nf">clickedButtonAtIndex:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">buttonIndex</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIButton</span> <span class="o">*</span><span class="n">sender</span> <span class="o">=</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="n">alertView</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kRepresentedObject</span><span class="p">);</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">buttonLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[[</span><span class="n">sender</span> <span class="n">titleLabel</span><span class="p">]</span> <span class="n">text</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>结合以上两者的最佳实践</h2>

<p>在Cocoa里面，我们经常会见到user info这样一个属性，（比如NSNotification.userinfo），代表用户自定义的payload数据。</p>

<p>同时一般而言，显式的使用objc的runtime特性并不是一个良好的编程习惯，故而我们可以使用category给UIAlert添加一个user info的property，以将objc的runtime代码进行隐藏。</p>

<p>代码与前面给出的类似，你可以在Github下载到完整Demo。
<a href="https://github.com/lancy/UIAlertViewUserinfo">传送门</a></p>

<p>使用效果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">UIAlertView</span> <span class="o">*</span><span class="n">alert</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAlertView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTitle:</span><span class="s">@&quot;Alert One&quot;</span> <span class="nl">message:</span><span class="s">@&quot;I gonna show the userinfo&quot;</span> <span class="nl">delegate:</span><span class="n">self</span> <span class="nl">cancelButtonTitle:</span><span class="s">@&quot;OK&quot;</span> <span class="nl">otherButtonTitles:</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">alert</span> <span class="nl">setUserinfo:</span><span class="err">@</span><span class="p">{</span><span class="s">@&quot;message&quot;</span><span class="o">:</span> <span class="s">@&quot;I&#39;m userinfo of alert one&quot;</span><span class="p">}];</span>
</span><span class='line'><span class="p">[</span><span class="n">alert</span> <span class="n">show</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-05-22T00:00:00+08:00" pubdate data-updated="true">May 22<span>nd</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/blog/2013/05/22/objective-c-associative-references-part2/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/05/16/use-corelocation-to-track-travel-distance/">
		
			使用CoreLocation来跟踪用户距离</a>
	</h2>
	<div class="entry-content">
		<h1>使用CoreLocation来跟踪用户距离</h1>

<h2>背景</h2>

<p>CoreLocation是一个强大的Framework，他能帮助开发使其免于复杂的位置处理而专注于应用逻辑的开发。然而CoreLocation并没有提供的对用户移动距离的检测，当我们开发跑步类运动类应用时，就不可避免的需要这项功能。凑巧有一个朋友让我帮忙做一个GPS模块，故而就有了CYLocationManager。</p>

<p>代码在Github开源托管，<a href="https://github.com/lancy/LocationManager">传送门</a></p>

<h2>实现说明</h2>

<p>Readme有详细的使用说明，我在这里主要描述一下实现的一些要点。</p>

<p>基本的思路既是不断的采样用户数据，过滤掉误差较大的数据，取相对误差较小的数据进行记录，然后计算相邻记录点之间的距离。</p>

<p>简单描述一下几个要点：</p>

<ol>
<li>当用户开始运动，程序开始追踪，设置一个强制标记，（needForceCalculation），表示程序应该忽略其他因素，立刻获取一个点坐标。用做起始值。</li>
<li>设置了CLLocationManager.headingFilter，使得程序能在用户转向的时候收到通知，此时设置一个强制标记（needForceCalculation），使得程序在用户转向的时候，记录下转向时所在的位置，以减少误差。</li>
<li>设置CLLocationManager.distanceFilter，使得程序在变化的位置大于一定数值时该更新位置才算为有效，可以避免用户在一个地方停留，由于误差记录距离依然增长。</li>
<li>当程序获得位置更新时，若精度合格，切时间戳合理，则加入一个数组，用于之后的计算。若精度大于某个阀值，则认为该位置对跟踪距离无帮助，此时将该位置舍去。</li>
<li>数组currentKeepLocations来记录最近更新的k个位置，并每隔t秒，从该数组中，取出精度最高的位置记录。（精度见CLLocation.horizontalAccuracy）</li>
<li>注意，当用户停止运动时，位置将无法得到更新，此时需要设置一个timer，令其在一定时间内强制获得一个位置。</li>
<li>该程序还可以通过每次更新位置时获得的位置的精确度来判断GPS信号的强弱。</li>
</ol>


<h2>联系我</h2>

<p>如果你对这个程序有疑问，请联系我</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-05-16T00:00:00+08:00" pubdate data-updated="true">May 16<span>th</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/blog/2013/05/16/use-corelocation-to-track-travel-distance/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2013/05/02/OSX-iOS-Threading-Programming/">
		
			OS X/iOS 多线程编程小结</a>
	</h2>
	<div class="entry-content">
		<h2>前言</h2>

<p>我来填坑了。欠下的多线程，趁着假期无聊，赶紧码了。</p>

<p>好吧，如我的这篇博文《<a href="http://gracelancy.com/?p=116">OS X/iOS 并发编程小结</a>》最后一段所说，虽然queue那样的并发编程非常方便，但在音频、视频这些需求最小延时的情况下，queue并发编程即使有优先级也并不能保证任务在特定的时间得到执行。故而，这种情况下还是需要我们直接操作线程。</p>

<p>注：除开这种情况外，我建议（苹果也建议），各位还是乖乖用queue并发编程就好了。</p>

<h2>什么是多线程</h2>

<p>简而言之，主要有三个术语：线程、进程、任务。
这里不想给大家上操作系统课啦，大家不明白的google一下或者回去翻翻书就好。</p>

<h2>APPLE的多线程技术</h2>

<h3>APPLE关于多线程的整个架构</h3>

<p><img src="http://lianxu.me/images/post/threadlayout.jpg" alt="image" />
（注：NSOperationQueue是在GCD上面的）</p>

<p>ok，我一个一个介绍：</p>

<ol>
<li>多线程底层实现的机制是Mach的线程。坦白的说，mach我压根不懂。苹果也说了，你几乎不会用到。不过如果你真的有兴趣研究，可以看这里：<a href="https://developer.apple.com/library/mac/#documentation/Darwin/Conceptual/KernelProgramming/Mach/Mach.html">Kernel Programming Guide</a> 里面的关于Mach的那部分。</li>
<li>pthread(POSIX threads)。这是传统的多线程，C-based interface，非常灵活。如果你写的不是Cocoa应用，这是实现多线程的最好选择。</li>
<li>NSThread，Cocoa的线程实现。当你在写Cocoa应用而又需要进行直接的线程操作的时候，我认为NSThread是比pthread更好的选择。虽然你依然可以使用pthread在Cocoa程序上，但是会有一些在Cocoa程序需要遵循的规则。我会在后面说明。</li>
<li>GCD和NSOperationQueue略</li>
</ol>


<h3>同步工具</h3>

<p>锁(locks)，条件(condition)，原子操作(atomic)</p>

<h3>线程间通信</h3>

<ol>
<li>Direct messaging: Cocoa应用可以直接perform某个selector在指定线程</li>
<li>全局变量，共享内存和对象。</li>
<li>Conditions：一种特殊类型的锁</li>
<li>Run loop sources：简单的来说，run loop是用来在线程上管理时间异步到达的工具。run loop能为线程监听一个或多个事件源(event sources)。run loop能把线程置于休眠状态，而当事件到达时，系统能唤醒线程并把事件分发给run loop，而后run loop能将事件分发给特定的handler。</li>
<li>Ports and sockets：也使用run loop，不同之处在于可以进行多进程通信</li>
<li>Message queues：历史遗物，一种多进程通信的玩意，才用FIFO的信息队列，但是有效率问题，</li>
<li>Cocoa distributed objects：好高级的技术，可以在call不同cocoa应用的object，甚至跨越网络的不同计算机上的cocoa应用。</li>
</ol>


<p>（老实说，后面几种我原先压根就没见过，为了弄懂他们是啥，看了好几篇文档。总结到这里，我的压力也感觉越来越大。觉得自己图样图拿衣服。。写了点多线程代码，就想总结OSX\iOS多线程编程。这才发现里面内容之多，细节之细令人发指。远不是整理一个并发编程能比的。我水平恐怕也就能堪堪掌握个大概框架，就操作系统课上的那点东西，跟生产环节下的多线程相比真是弱爆了。。）</p>

<p>所以从这里开始，后面我打算走实用主义，直接小结一下如何写多线程程序好了。</p>

<h2>线程管理</h2>

<h3>使用NSThread创建线程</h3>

<ul>
<li>类方法detachNewThreadSelector:toTarget:withObject:</li>
<li>创建一个NSThread对象initWithTarget:selector:object:，并调用start方法</li>
</ul>


<p>需要注意的是，这两种方法创建的线程，是分离（detach）的线程。detached的意思即，当线程退出的时候，系统会自动回收线程资源。当线程运行的时候，可以使用performSelector:onThread:withObject:waitUntilDone:modes来进行线程通信。其中modes用来指定run loop</p>

<p>注意：在大部分情况下，脱离线程更适用，因为它允许系统在线程完成的时候自动回收。如果你想创建可连接的线程（Joinable thread），唯一的办法是使用pthread。</p>

<h3>使用pthread创建线程</h3>

<p><a href="http://developer.apple.com/library/ios/#documentation/System/Conceptual/ManPages_iPhoneOS/man3/pthread.3.html#//apple_ref/doc/man/3/pthread">参看pthread手册</a></p>

<p>需要注意的几点：</p>

<ol>
<li>在cocoa程序上仅使用pthread，你需要先使用NSThread生成一个线程之后立即退出。就能保证Cocoa框架切换到多线程模式，来启用一些锁或者其他的同步技术来保证Cocoa框架代码的正确执行。如果你不这么做，当涉及到Cocoa框架的操作时有可能会照成不可预料的后果。</li>
<li>pthread和Cocoa的锁是完全可以混用的，（我就这么做过，因为pthread的锁更灵活），但是对于指定的一个锁，必须使用同类型的接口来操作，即你不能同时用pthread和NSLock同时操作一个锁。</li>
</ol>


<h3>使用NSObject创建线程</h3>

<p>performSelectorInBackground:withObject:也会生成一个脱离线程。你还可以在该线程里面使用performSelectorOnMainThread:withObject:waitUntilDone:modes:</p>

<h3>线程的优先级</h3>

<p>创建的线程的优先级和所处在的线程是相同的，优先级高的线程比优先级低的线程能获得更多运行机会，但并不能保证线程的具体执行时间和顺序。内核的调度算法会决定该运行哪个线程。</p>

<p>NSThread 的 setThreadPriority:以及pthread_setschedparam 可以改变线程的优先级。</p>

<p>注意：一般来说，保持默认优先级是一个不错的选择。更改某些线程的优先级，会增加某些较低优先级的线程的饥饿。若高优先级和低优先级的线程又有交互的需求，那么低优先级就有可能因为得到运行机会的难度而阻塞其他线程，造成线程瓶颈。</p>

<h3>关于自动释放池 （autorelease pool）</h3>

<p>autorelease pool用于自动释放pool里面捕获的autorelease对象。</p>

<p>理论上来说，每一个线程都应该有一个autorelease pool，主
线程在main.m里面XCode会为你创建一个。但当你创建一个线程的时候，你第一件应该做的事，就是创建一个autorelease pool。</p>

<p>非ARC之前，你使用NSAutoreleasePool，之后你可以使用@autoreleasepool。</p>

<p>注意：在ARC环境下你仍然不能忽略autorelease pool，因为ARC仍然使用autorelease来进行release操作，且他并不会为你自动的创建autorelease pool。BTW，除了在线程里面你会需要autorelease pool之外，在次数巨大或者多重的for-loop里面你也会使用autorelease pool，来避免一次alloc和release数量巨大的对象。</p>

<h3>中断线程</h3>

<p>（未完待续。。。写不动了。。）</p>

<h2>Run Loop 详解</h2>

<h2>线程同步 详解</h2>

<h2>Cocoa的线程安全</h2>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2013-05-02T00:00:00+08:00" pubdate data-updated="true">May 2<span>nd</span>, 2013</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/blog/2013/05/02/OSX-iOS-Threading-Programming/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2014

    Lancy

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'gracelancy';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>